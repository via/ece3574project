// checksum 0xa193 version 0x30001
/*
  This file was generated by the Mobile Qt Application wizard of Qt Creator.
  MainWindow is a convenience class containing mobile device specific code
  such as screen orientation handling.
  It is recommended not to modify this file, since newer versions of Qt Creator
  may offer an updated version of it.
*/

#include "mainwindow.h"
#include "ui_mainwindow.h"
#include "settingsdialog.h"

#include <QtCore>
#include <QtGui>
#include <QAccelerometer>
#include <QGeoPositionInfoSource>
#include <QFileDialog>

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent), ui(new Ui::MainWindow)
{
    ui->setupUi(this);
    x = 0;
    y = 0;
    z = 0;
    QAction *settingsAction = new QAction("Settings", this);
    QAction *openAction = new QAction("Open Trace", this);
    QAction *saveAction = new QAction("Save Trace", this);
    QAction *resetAction = new QAction("Reset Trace", this);
    connect(settingsAction, SIGNAL(triggered()), this, SLOT(settingsWindowSlot()));
    connect(openAction, SIGNAL(triggered()), this, SLOT(openTrace()));
    connect(saveAction, SIGNAL(triggered()), this, SLOT(closeTrace()));
    connect(resetAction, SIGNAL(triggered()), this, SLOT(resetTrace()));
    QMenu *menu = new QMenu("Fremantle", this);
    menu->addAction(settingsAction);
    menu->addAction(openAction);
    menu->addAction(saveAction);
    menu->addAction(resetAction);
    menuBar()->addMenu(menu);
    commitSettings("X", "Y", "Z");
    list = new DataPointList(1, 1);
    const MapDataPoint *mdp = new MapDataPoint(this, 3, 3, 15, 0, 0);
    list->append(mdp);
    mdp = new MapDataPoint(this, 3.02, 3.03, 0, 15, 0);
    list->append(mdp);
    ui->tracer->setList(list);
    accel = new QAccelerometer();
    pos = QGeoPositionInfoSource::createDefaultSource(parent);
    connect(accel, SIGNAL(readingChanged()), this, SLOT(newAccelReading()));
    if (pos) {
      connect(pos, SIGNAL(positionUpdated(QGeoPositionInfo)), this,
            SLOT(posUpdate(QGeoPositionInfo)));
      pos->startUpdates();
    }
    accel->start();
}

MainWindow::~MainWindow()
{
    delete ui;
}

void MainWindow::setOrientation(ScreenOrientation orientation)
{
#if defined(Q_OS_SYMBIAN)
    // If the version of Qt on the device is < 4.7.2, that attribute won't work
    if (orientation != ScreenOrientationAuto) {
        const QStringList v = QString::fromAscii(qVersion()).split(QLatin1Char('.'));
        if (v.count() == 3 && (v.at(0).toInt() << 16 | v.at(1).toInt() << 8 | v.at(2).toInt()) < 0x040702) {
            qWarning("Screen orientation locking only supported with Qt 4.7.2 and above");
            return;
        }
    }
#endif // Q_OS_SYMBIAN

    Qt::WidgetAttribute attribute;
    switch (orientation) {
#if QT_VERSION < 0x040702
    // Qt < 4.7.2 does not yet have the Qt::WA_*Orientation attributes
    case ScreenOrientationLockPortrait:
        attribute = static_cast<Qt::WidgetAttribute>(128);
        break;
    case ScreenOrientationLockLandscape:
        attribute = static_cast<Qt::WidgetAttribute>(129);
        break;
    default:
    case ScreenOrientationAuto:
        attribute = static_cast<Qt::WidgetAttribute>(130);
        break;
#else // QT_VERSION < 0x040702
    case ScreenOrientationLockPortrait:
        attribute = Qt::WA_LockPortraitOrientation;
        break;
    case ScreenOrientationLockLandscape:
        attribute = Qt::WA_LockLandscapeOrientation;
        break;
    default:
    case ScreenOrientationAuto:
        attribute = Qt::WA_AutoOrientation;
        break;
#endif // QT_VERSION < 0x040702
    };
    setAttribute(attribute, true);
}

void MainWindow::showExpanded()
{
#ifdef Q_OS_SYMBIAN
    showFullScreen();
#elif defined(Q_WS_MAEMO_5) || defined(Q_WS_MAEMO_6)
    showMaximized();
#else
    show();
#endif
}


void MainWindow::settingsWindowSlot()
{

        SettingsDialog *sd = new SettingsDialog(this);
        sd->show();

}

void MainWindow::commitSettings(const QString &Raxis,
                    const QString &Gaxis,
                    const QString &Baxis)
{

        if (Raxis == "X")
                this->Raxis = X;
        else if (Raxis == "Y")
                this->Raxis = Y;
        else if (Raxis == "Z")
                this->Raxis = Z;

        if (Gaxis == "X")
                this->Gaxis = X;
        else if (Gaxis == "Y")
                this->Gaxis = Y;
        else if (Gaxis == "Z")
                this->Gaxis = Z;

        if (Baxis == "X")
                this->Baxis = X;
        else if (Baxis == "Y")
                this->Baxis = Y;
        else if (Baxis == "Z")
                this->Baxis = Z;

        ui->tracer->setR(this->Raxis);
        ui->tracer->setG(this->Gaxis);
        ui->tracer->setB(this->Baxis);
        ui->tracer->update();
}

void MainWindow::newAccelReading() {

  QAccelerometerReading *reading = accel->reading();
  x = reading->x();
  y = reading->y();
  z = reading->z();
  int red = ( Raxis == X ? x :
      ( Raxis == Y ? y : z)) * 5 + 127;
  int green = ( Gaxis == X ? x :
      ( Gaxis == Y ? y : z)) * 5 + 127;
  int blue = ( Baxis == X ? x :
      ( Baxis == Y ? y : z)) * 5 + 127;

  ui->verticalSlider_2->setSliderPosition(red);
  ui->verticalSlider_3->setSliderPosition(green);
  ui->verticalSlider->setSliderPosition(blue);



}

void MainWindow::posUpdate(const QGeoPositionInfo & update) {
  const MapDataPoint *mdp = new MapDataPoint(0, update.coordinate().latitude(),
      update.coordinate().longitude(), x, y, z);

  list->append(mdp);

}

void MainWindow::openTrace() {

  QString filename = QFileDialog::getOpenFileName();
  QFile file(filename);
  if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {
    return;
  }

  QTextStream instream(&file);

  while (!instream.atEnd()) {
    MapDataPoint *mdp = new MapDataPoint();
    instream >> *mdp;
    if (instream.atEnd()) break;
    const MapDataPoint *mdp_c = mdp;
    list->append(mdp_c);

  }
  file.close();

  ui->tracer->update();

}

void MainWindow::closeTrace() {

  QString filename = QFileDialog::getSaveFileName();
  QFile file(filename);
  if (!file.open(QIODevice::WriteOnly | QIODevice::Text)) {
    return;
  }

  QTextStream outstream(&file);

  DataPointList::const_iterator iter;
  for (iter = list->constBegin(); iter != list->constEnd(); ++iter) {
    outstream << **iter << endl;
  }

  file.close();
  

}

void MainWindow::resetTrace() {

  list->clear();
  ui->tracer->update();

}

void MainWindow::paintEvent(QPaintEvent *ev) {

  QPainter painter(this);
  painter.fillRect(painter.viewport(), QColor::fromRgb(
        ui->verticalSlider_2->value(),
        ui->verticalSlider_3->value(),
        ui->verticalSlider->value()));
  
}

void MainWindow::on_verticalSlider_2_valueChanged(int value)
{
    update();
}

void MainWindow::on_verticalSlider_3_valueChanged(int value)
{
    update();
}

void MainWindow::on_verticalSlider_valueChanged(int value)
{
    update();
}
